package main

import (
	"bytes"
	envseed "envseed/internal/envseed"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

func main() {
	entries := envseed.ErrorDetails()

	// Validation: band membership, dense numbering per band,
	// exit value consistency, and EVE-103 band constraints.
	type bandKey struct{ exit, band int }
	groups := map[bandKey][]int{}
	prevCodeOrderOK := true
	var lastExit, lastSub int
	for i, e := range entries {
		exit, sub := parseCode(e.Code)
		if exit == 0 && sub == 0 {
			die("invalid code format: %s", e.Code)
		}
		// Exit value in detail must match the code's exit segment.
		if e.Detail.Exit != exit {
			die("exit mismatch between code and detail: %s (exit=%d, detail.Exit=%d)", e.Code, exit, e.Detail.Exit)
		}
		// Check global ascending order (Exit,Sub).
		if i > 0 && (exit < lastExit || (exit == lastExit && sub < lastSub)) {
			prevCodeOrderOK = false
		}
		lastExit, lastSub = exit, sub

		band, ok := bandOf(sub)
		if !ok {
			die("subcode out of band: %s (sub=%d)", e.Code, sub)
		}
		// EVE-103 band change: B6 retired; enforce B0..B5 only.
		if exit == 103 {
			if band > 5 {
				die("invalid band for EVE-103: use B5 (501..599) instead of B%d (sub=%d)", band, sub)
			}
			if sub >= 600 && sub < 700 {
				die("EVE-103-B6 is retired; renumber to EVE-103-501..599")
			}
		}
		k := bandKey{exit: exit, band: band}
		groups[k] = append(groups[k], sub)
	}
	if !prevCodeOrderOK {
		die("entries not sorted by (exit,subcode) ascending")
	}
	for k, subs := range groups {
		sort.Ints(subs)
		start := bandStart(k.band)
		if len(subs) > 0 && subs[0] != start {
			die("band start mismatch: exit=%d band=B%d expected %d got %d", k.exit, k.band, start, subs[0])
		}
		for i := 0; i < len(subs); i++ {
			if subs[i] != start+i {
				die("gap in band: exit=%d band=B%d missing %d (found %d)", k.exit, k.band, start+i, subs[i])
			}
		}
	}

	var buf bytes.Buffer
	// DO NOT EDIT notice for generated file.
	buf.WriteString("<!-- DO NOT EDIT: Generated by cmd/docs/errors; run 'go generate ./...' -->\n")
	buf.WriteString("# Error Codes\n\n")

	for _, entry := range entries {
		detail := entry.Detail
		// Emit an explicit anchor derived from the code (lowercased).
		anchor := strings.ToLower(entry.Code)
		fmt.Fprintf(&buf, "<a id=\"%s\"></a>\n", anchor)
		// Heading uses code only to stabilize anchors.
		fmt.Fprintf(&buf, "## %s\n\n", entry.Code)
		fmt.Fprintf(&buf, "- Exit code: `%d`\n", detail.Exit)
		// Use an inline-code fence length that exceeds any backtick run in the message
		fence := backtickFence(detail.Message)
		fmt.Fprintf(&buf, "- CLI message: %s%s%s\n", fence, detail.Message, fence)
		fmt.Fprintf(&buf, "- Guidance: %s\n\n", detail.Detail)
	}

	root := findModuleRoot()
	outPath := filepath.Join(root, "docs", "errors.md")
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		panic(err)
	}
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

// findModuleRoot walks up from the current working directory to locate
// the directory containing go.mod. Falls back to the CWD on failure.
func findModuleRoot() string {
	wd, err := os.Getwd()
	if err != nil {
		return "."
	}
	dir := wd
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir || parent == "" {
			// Reached filesystem root
			return wd
		}
		dir = parent
	}
}

// parseCode splits EVE-<exit>-<sub> into ints.
func parseCode(code string) (int, int) {
	parts := strings.Split(code, "-")
	if len(parts) != 3 {
		return 0, 0
	}
	exit, _ := strconv.Atoi(parts[1])
	sub, _ := strconv.Atoi(parts[2])
	return exit, sub
}

// bandOf returns Bn for subcode using: B0=1..99, B1=101..199, B2=201..299â€¦
func bandOf(sub int) (int, bool) {
	switch {
	case sub >= 1 && sub <= 99:
		return 0, true
	default:
		if sub%100 >= 1 && sub%100 <= 99 { // n>=1 bands
			return sub / 100, true
		}
		return 0, false
	}
}

func bandStart(band int) int {
	if band == 0 {
		return 1
	}
	return band*100 + 1
}

func die(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "generator error: "+format+"\n", args...)
	os.Exit(1)
}

// backtickFence returns an inline-code backtick fence whose length
// is greater than any run of backticks present in s, so the fence
// can safely wrap s without escaping.
func backtickFence(s string) string {
	max := 0
	run := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '`' {
			run++
			if run > max {
				max = run
			}
		} else {
			run = 0
		}
	}
	return strings.Repeat("`", max+1)
}
